<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Runner - Ultimate Edition</title>
    <meta name="description" content="Un jeu runner cyberpunk addictif ! Collecte des cristaux, √©vite les ennemis, bats ton record !">
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow-x: hidden; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        const Play = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );
        
        const RotateCcw = ({ size = 24 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="1 4 1 10 7 10"></polyline>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
            </svg>
        );
        
        const Pause = ({ size = 24, className = '' }) => (
            <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
        );

        const NeonRunner = () => {
          const canvasRef = useRef(null);
          const [gameState, setGameState] = useState('menu');
          const [score, setScore] = useState(0);
          const [highScore, setHighScore] = useState(() => {
            const saved = localStorage.getItem('neon-runner-highscore');
            return saved ? parseInt(saved) : 0;
          });
          const [difficulty, setDifficulty] = useState('normal');
          const [isPaused, setIsPaused] = useState(false);
          const gameLoop = useRef(null);
          
          const game = useRef({
            player: {
              x: 120, y: 0, width: 55, height: 80,
              velocityY: 0, isJumping: false, isDucking: false,
              groundY: 350, runCycle: 0,
              health: 3, maxHealth: 3,
              shield: false, shieldTime: 0,
              invincible: false, invincibleTime: 0
            },
            obstacles: [], collectibles: [], powerups: [], particles: [],
            buildings: [], clouds: [],
            speed: 4, baseSpeed: 4, maxSpeed: 9,
            slowMo: false, slowMoTime: 0,
            magnet: false, magnetTime: 0,
            gravity: 0.6, jumpPower: -13,
            score: 0, combo: 0, comboTimer: 0,
            gameFrame: 0, bgScroll: 0, cloudScroll: 0
          }).current;

          const difficultySettings = {
            easy: { speed: 3.5, spawnRate: 160, maxSpeed: 8 },
            normal: { speed: 4, spawnRate: 130, maxSpeed: 9 },
            hard: { speed: 5, spawnRate: 100, maxSpeed: 11 }
          };

          const saveHighScore = (score) => {
            localStorage.setItem('neon-runner-highscore', score.toString());
          };

          useEffect(() => {
            game.player.y = game.player.groundY;
            for (let i = 0; i < 6; i++) {
              game.buildings.push({
                x: i * 250, height: 80 + Math.random() * 120,
                width: 60 + Math.random() * 50, windows: Math.floor(Math.random() * 3) + 2
              });
            }
            for (let i = 0; i < 4; i++) {
              game.clouds.push({
                x: i * 300, y: 30 + Math.random() * 80, width: 80 + Math.random() * 40
              });
            }
          }, []);

          const drawPlayer = (ctx) => {
            const p = game.player;
            ctx.save();
            ctx.translate(p.x + p.width / 2, p.y + p.height / 2);
            const bodyColor = p.invincible ? '#ffff00' : '#00ffff';
            const accentColor = '#ff00ff';
            ctx.shadowBlur = p.invincible ? 25 : 15;
            ctx.shadowColor = bodyColor;

            if (p.isDucking) {
              ctx.fillStyle = bodyColor;
              ctx.beginPath();
              ctx.arc(-10, 5, 14, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = accentColor;
              ctx.fillRect(-18, 3, 12, 4);
              ctx.fillStyle = bodyColor;
              ctx.fillRect(-5, 0, 35, 18);
              ctx.fillRect(-5, 8, 8, 15);
              ctx.fillRect(22, 8, 8, 15);
            } else {
              const bounce = p.isJumping ? 0 : Math.sin(p.runCycle * 0.3) * 2;
              ctx.fillStyle = bodyColor;
              ctx.beginPath();
              ctx.arc(0, -22 + bounce, 16, 0, Math.PI * 2);
              ctx.fill();
              ctx.fillStyle = accentColor;
              ctx.fillRect(-12, -24 + bounce, 18, 5);
              ctx.fillStyle = bodyColor;
              ctx.fillRect(-12, -6 + bounce, 24, 30);
              ctx.fillStyle = accentColor;
              ctx.fillRect(-8, 0 + bounce, 16, 3);
              ctx.fillRect(-8, 8 + bounce, 16, 3);
              const armSwing = p.isJumping ? 0 : Math.sin(p.runCycle * 0.3) * 10;
              ctx.fillRect(-18, -2 + bounce + armSwing, 6, 20);
              ctx.fillRect(12, -2 + bounce - armSwing, 6, 20);
              if (p.isJumping) {
                ctx.fillRect(-10, 24, 8, 18);
                ctx.fillRect(2, 24, 8, 18);
              } else {
                const leg1 = Math.sin(p.runCycle * 0.3) * 8;
                const leg2 = Math.sin(p.runCycle * 0.3 + Math.PI) * 8;
                ctx.fillRect(-10, 24 + leg1, 8, 20);
                ctx.fillRect(2, 24 + leg2, 8, 20);
                ctx.fillStyle = accentColor;
                ctx.fillRect(-10, 44 + leg1, 10, 4);
                ctx.fillRect(2, 44 + leg2, 10, 4);
              }
            }
            if (p.shield) {
              ctx.strokeStyle = '#00ffff';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(0, 0, 50, 0, Math.PI * 2);
              ctx.stroke();
            }
            ctx.shadowBlur = 0;
            ctx.restore();
          };

          const createObstacle = () => {
            const types = ['low', 'high', 'drone', 'robot'];
            const type = types[Math.floor(Math.random() * types.length)];
            if (type === 'drone') return { x: 1200, y: 220 + Math.random() * 100, width: 45, height: 35, type: 'drone', color: '#ff3366', float: 0 };
            else if (type === 'robot') return { x: 1200, y: 395, width: 50, height: 40, type: 'robot', color: '#ff6600' };
            else if (type === 'low') return { x: 1200, y: 395, width: 40, height: 40, type: 'low', color: '#ff0080' };
            else return { x: 1200, y: 280, width: 60, height: 30, type: 'high', color: '#ff0080' };
          };

          const createCollectible = () => ({ x: 1200, y: 250 + Math.random() * 120, size: 14, collected: false, pulse: 0 });
          const createPowerup = () => {
            const types = ['shield', 'slowmo', 'magnet', 'health'];
            return { x: 1200, y: 250 + Math.random() * 100, size: 18, type: types[Math.floor(Math.random() * types.length)], collected: false, rotation: 0 };
          };
          const createParticle = (x, y, color) => {
            for (let i = 0; i < 10; i++) {
              game.particles.push({ x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8, life: 30, color, size: Math.random() * 4 + 2 });
            }
          };

          useEffect(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            canvas.width = 1200;
            canvas.height = 500;

            const handleKeyDown = (e) => {
              if (gameState !== 'playing') return;
              if (e.code === 'KeyP') { e.preventDefault(); setIsPaused(p => !p); return; }
              if (isPaused) return;
              if ((e.code === 'Space' || e.code === 'ArrowUp') && !game.player.isJumping && !game.player.isDucking) {
                e.preventDefault();
                game.player.velocityY = game.jumpPower;
                game.player.isJumping = true;
              }
              if (e.code === 'ArrowDown' && !game.player.isJumping) {
                e.preventDefault();
                game.player.isDucking = true;
              }
            };

            const handleKeyUp = (e) => { if (e.code === 'ArrowDown') game.player.isDucking = false; };
            const handleTouch = (e) => {
              if (gameState !== 'playing' || isPaused) return;
              e.preventDefault();
              const touch = e.touches[0];
              const rect = canvas.getBoundingClientRect();
              const touchY = touch.clientY - rect.top;
              if (touchY < canvas.height / 2) {
                if (!game.player.isJumping && !game.player.isDucking) {
                  game.player.velocityY = game.jumpPower;
                  game.player.isJumping = true;
                }
              } else {
                if (!game.player.isJumping) {
                  game.player.isDucking = true;
                  setTimeout(() => { game.player.isDucking = false; }, 400);
                }
              }
            };

            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('touchstart', handleTouch);

            return () => {
              window.removeEventListener('keydown', handleKeyDown);
              window.removeEventListener('keyup', handleKeyUp);
              canvas.removeEventListener('touchstart', handleTouch);
            };
          }, [gameState, isPaused]);

          const startGame = (diff) => {
            setDifficulty(diff);
            const settings = difficultySettings[diff];
            game.player.y = game.player.groundY;
            game.player.velocityY = 0;
            game.player.isJumping = false;
            game.player.isDucking = false;
            game.player.health = 3;
            game.player.shield = false;
            game.player.invincible = false;
            game.obstacles = [];
            game.collectibles = [];
            game.powerups = [];
            game.particles = [];
            game.speed = settings.speed;
            game.baseSpeed = settings.speed;
            game.maxSpeed = settings.maxSpeed;
            game.slowMo = false;
            game.magnet = false;
            game.gameFrame = 0;
            game.score = 0;
            game.combo = 0;
            game.comboTimer = 0;
            game.bgScroll = 0;
            game.cloudScroll = 0;
            setScore(0);
            setIsPaused(false);
            setGameState('playing');
          };

          const checkCollision = (rect1, rect2) => {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect1.height > rect2.y;
          };

          useEffect(() => {
            if (gameState !== 'playing' || isPaused) return;
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const settings = difficultySettings[difficulty];

            const animate = () => {
              game.gameFrame++;
              game.player.runCycle++;
              const effectiveSpeed = game.slowMo ? game.speed * 0.5 : game.speed;

              const bgGradient = ctx.createLinearGradient(0, 0, 0, 500);
              bgGradient.addColorStop(0, '#0a0420');
              bgGradient.addColorStop(0.5, '#1a0a40');
              bgGradient.addColorStop(1, '#2a1050');
              ctx.fillStyle = bgGradient;
              ctx.fillRect(0, 0, 1200, 500);

              ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
              for (let i = 0; i < 80; i++) {
                ctx.fillRect((i * 137) % 1200, (i * 73) % 250, 2, 2);
              }

              game.cloudScroll += effectiveSpeed * 0.2;
              game.clouds.forEach((cloud) => {
                let cloudX = cloud.x - (game.cloudScroll % 1200);
                if (cloudX < -cloud.width) cloudX += 1200;
                ctx.fillStyle = 'rgba(100, 150, 200, 0.2)';
                ctx.fillRect(cloudX, cloud.y, cloud.width, 30);
                ctx.fillRect(cloudX + 20, cloud.y - 10, cloud.width - 40, 20);
                ctx.fillRect(cloudX + 1200, cloud.y, cloud.width, 30);
                ctx.fillRect(cloudX + 1220, cloud.y - 10, cloud.width - 40, 20);
              });

              game.bgScroll += effectiveSpeed * 0.5;
              game.buildings.forEach((building, i) => {
                let buildingX = building.x - (game.bgScroll % 1500);
                if (buildingX < -building.width) buildingX += 1500;
                const drawBuilding = (x) => {
                  ctx.fillStyle = '#1a1a3a';
                  ctx.fillRect(x, 435 - building.height, building.width, building.height);
                  ctx.fillStyle = 'rgba(255, 255, 100, 0.6)';
                  for (let w = 0; w < building.windows; w++) {
                    for (let h = 0; h < Math.floor(building.height / 30); h++) {
                      if ((i + w + h) % 10 > 3) {
                        ctx.fillRect(x + 10 + w * 20, 445 - building.height + h * 30, 12, 18);
                      }
                    }
                  }
                  ctx.strokeStyle = '#ff00ff';
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.moveTo(x + building.width / 2, 435 - building.height);
                  ctx.lineTo(x + building.width / 2, 415 - building.height);
                  ctx.stroke();
                  ctx.fillStyle = '#ff00ff';
                  ctx.beginPath();
                  ctx.arc(x + building.width / 2, 410 - building.height, 4, 0, Math.PI * 2);
                  ctx.fill();
                };
                drawBuilding(buildingX);
                drawBuilding(buildingX + 1500);
              });

              ctx.strokeStyle = 'rgba(138, 43, 226, 0.15)';
              ctx.lineWidth = 1;
              const gridOffset = (game.gameFrame * effectiveSpeed * 0.5) % 50;
              for (let i = -gridOffset; i < 1200; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 500);
                ctx.stroke();
              }
              ctx.shadowBlur = 25;
              ctx.shadowColor = '#00ffff';
              ctx.strokeStyle = '#00ffff';
              ctx.lineWidth = 4;
              ctx.beginPath();
              ctx.moveTo(0, 435);
              ctx.lineTo(1200, 435);
              ctx.stroke();
              ctx.shadowBlur = 0;

              if (!game.player.isDucking) {
                game.player.velocityY += game.gravity;
                game.player.y += game.player.velocityY;
              } else {
                game.player.y = game.player.groundY;
                game.player.velocityY = 0;
              }

              if (game.player.y >= game.player.groundY) {
                game.player.y = game.player.groundY;
                game.player.velocityY = 0;
                game.player.isJumping = false;
              }

              drawPlayer(ctx);

              if (game.player.shieldTime > 0) { game.player.shieldTime--; if (game.player.shieldTime === 0) game.player.shield = false; }
              if (game.player.invincibleTime > 0) { game.player.invincibleTime--; if (game.player.invincibleTime === 0) game.player.invincible = false; }
              if (game.slowMoTime > 0) { game.slowMoTime--; if (game.slowMoTime === 0) game.slowMo = false; }
              if (game.magnetTime > 0) { game.magnetTime--; if (game.magnetTime === 0) game.magnet = false; }
              if (game.comboTimer > 0) { game.comboTimer--; if (game.comboTimer === 0) game.combo = 0; }

              if (game.gameFrame % settings.spawnRate === 0) game.obstacles.push(createObstacle());
              if (game.gameFrame % 150 === 0) game.collectibles.push(createCollectible());
              if (game.gameFrame % 400 === 0) game.powerups.push(createPowerup());

              game.obstacles = game.obstacles.filter(obs => {
                obs.x -= effectiveSpeed;
                if (obs.type === 'drone') obs.float += 0.1;
                
                ctx.shadowBlur = 20;
                ctx.shadowColor = obs.color;
                ctx.fillStyle = obs.color;
                
                if (obs.type === 'drone') {
                  const floatY = Math.sin(obs.float) * 5;
                  ctx.fillRect(obs.x, obs.y + floatY, obs.width, obs.height);
                  ctx.fillStyle = '#ffffff';
                  ctx.fillRect(obs.x - 5, obs.y + floatY - 3, 8, 3);
                  ctx.fillRect(obs.x + obs.width - 3, obs.y + floatY - 3, 8, 3);
                  ctx.fillStyle = '#ffff00';
                  ctx.beginPath();
                  ctx.arc(obs.x + obs.width / 2, obs.y + floatY + obs.height / 2, 6, 0, Math.PI * 2);
                  ctx.fill();
                  obs.currentY = obs.y + floatY;
                } else if (obs.type === 'robot') {
                  ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                  ctx.fillStyle = '#333333';
                  ctx.fillRect(obs.x + 5, obs.y + obs.height - 8, obs.width - 10, 8);
                  ctx.fillStyle = '#ff0000';
                  ctx.fillRect(obs.x + 10, obs.y + 5, obs.width - 20, 15);
                  ctx.fillRect(obs.x - 12, obs.y + 10, 12, 5);
                } else if (obs.type === 'low') {
                  ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                  ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                  ctx.fillRect(obs.x + 2, obs.y + 2, obs.width - 4, 3);
                } else {
                  ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                  ctx.fillStyle = 'rgba(255, 0, 128, 0.3)';
                  ctx.fillRect(obs.x - 20, obs.y + obs.height / 2 - 2, 20, 4);
                }
                ctx.shadowBlur = 0;

                if (!game.player.invincible) {
                  const playerHitbox = {
                    x: game.player.x + 5,
                    y: game.player.isDucking ? game.player.y + 40 : game.player.y + 5,
                    width: game.player.width - 10,
                    height: game.player.isDucking ? 35 : game.player.height - 10
                  };
                  const obsHitbox = {
                    x: obs.x + 5,
                    y: (obs.type === 'drone' ? obs.currentY : obs.y) + 5,
                    width: obs.width - 10,
                    height: obs.height - 10
                  };

                  if (checkCollision(playerHitbox, obsHitbox)) {
                    if (game.player.shield) {
                      game.player.shield = false;
                      game.player.shieldTime = 0;
                      createParticle(obs.x, obs.y, '#00ffff');
                      return false;
                    } else {
                      game.player.health--;
                      game.player.invincible = true;
                      game.player.invincibleTime = 120;
                      createParticle(obs.x, obs.y, '#ff0000');
                      if (game.player.health <= 0) {
                        setGameState('gameover');
                        if (game.score > highScore) {
                          setHighScore(game.score);
                          saveHighScore(game.score);
                        }
                      }
                      return false;
                    }
                  }
                }
                return obs.x > -obs.width;
              });

              game.collectibles = game.collectibles.filter(col => {
                col.x -= effectiveSpeed;
                col.pulse += 0.1;
                if (!col.collected) {
                  const pulseSize = col.size + Math.sin(col.pulse) * 3;
                  if (game.magnet) {
                    const dx = game.player.x - col.x;
                    const dy = game.player.y - col.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < 200) {
                      col.x += dx * 0.1;
                      col.y += dy * 0.1;
                    }
                  }
                  ctx.shadowBlur = 20;
                  ctx.shadowColor = '#ffff00';
                  ctx.fillStyle = '#ffff00';
                  ctx.beginPath();
                  ctx.arc(col.x, col.y, pulseSize, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.fillStyle = '#ffffff';
                  ctx.beginPath();
                  ctx.arc(col.x, col.y, pulseSize * 0.4, 0, Math.PI * 2);
                  ctx.fill();
                  ctx.shadowBlur = 0;

                  const dist = Math.sqrt(
                    Math.pow(col.x - (game.player.x + game.player.width / 2), 2) + 
                    Math.pow(col.y - (game.player.y + game.player.height / 2), 2)
                  );
                  if (dist < col.size + 30) {
                    col.collected = true;
                    game.combo++;
                    game.comboTimer = 180;
                    game.score += 50 * game.combo;
                    setScore(game.score);
                    createParticle(col.x, col.y, '#ffff00');
                  }
                }
                return col.x > -col.size && !col.collected;
              });

              game.powerups = game.powerups.filter(pwp => {
                pwp.x -= effectiveSpeed;
                pwp.rotation += 0.1;
                if (!pwp.collected) {
                  ctx.save();
                  ctx.translate(pwp.x, pwp.y);
                  ctx.rotate(pwp.rotation);
                  if (pwp.type === 'shield') {
                    ctx.strokeStyle = '#00ffff';
                    ctx.lineWidth = 4;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(0, 0, pwp.size, 0, Math.PI * 2);
                    ctx.stroke();
                  } else if (pwp.type === 'slowmo') {
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff00ff';
                    ctx.beginPath();
                    ctx.moveTo(0, -pwp.size);
                    ctx.lineTo(pwp.size, pwp.size);
                    ctx.lineTo(-pwp.size, pwp.size);
                    ctx.closePath();
                    ctx.fill();
                  } else if (pwp.type === 'magnet') {
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ffff00';
                    ctx.fillRect(-pwp.size, -pwp.size / 2, pwp.size * 2, pwp.size);
                  } else if (pwp.type === 'health') {
                    ctx.fillStyle = '#ff0066';
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = '#ff0066';
                    ctx.beginPath();
                    ctx.arc(0, 0, pwp.size, 0, Math.PI * 2);
                    ctx.fill();
                  }
                  ctx.shadowBlur = 0;
                  ctx.restore();

                  const dist = Math.sqrt(
                    Math.pow(pwp.x - (game.player.x + game.player.width / 2), 2) + 
                    Math.pow(pwp.y - (game.player.y + game.player.height / 2), 2)
                  );
                  if (dist < pwp.size + 30) {
                    pwp.collected = true;
                    createParticle(pwp.x, pwp.y, '#ffffff');
                    if (pwp.type === 'shield') {
                      game.player.shield = true;
                      game.player.shieldTime = 300;
                    } else if (pwp.type === 'slowmo') {
                      game.slowMo = true;
                      game.slowMoTime = 300;
                    } else if (pwp.type === 'magnet') {
                      game.magnet = true;
                      game.magnetTime = 400;
                    } else if (pwp.type === 'health') {
                      game.player.health = Math.min(game.player.health + 1, game.player.maxHealth);
                    }
                  }
                }
                return pwp.x > -pwp.size && !pwp.collected;
              });

              game.particles = game.particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                return p.life > 0;
              });

              if (game.gameFrame % 600 === 0 && game.speed < game.maxSpeed) game.speed += 0.25;

              ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
              ctx.fillRect(10, 10, 150, 40);
              for (let i = 0; i < game.player.health; i++) {
                ctx.fillStyle = '#ff0066';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff0066';
                ctx.beginPath();
                ctx.arc(30 + i * 40, 30, 12, 0, Math.PI * 2);
                ctx.fill();
              }
              ctx.shadowBlur = 0;
              
              if (game.combo > 1) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillRect(10, 60, 120, 35);
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 20px Arial';
                ctx.fillText(`COMBO x${game.combo}`, 20, 85);
              }

              let pwY = 10;
              if (game.player.shield) { ctx.fillStyle = 'rgba(0, 255, 255, 0.8)'; ctx.fillRect(1150, pwY, 40, 30); pwY += 35; }
              if (game.slowMo) { ctx.fillStyle = 'rgba(255, 0, 255, 0.8)'; ctx.fillRect(1150, pwY, 40, 30); pwY += 35; }
              if (game.magnet) { ctx.fillStyle = 'rgba(255, 255, 0, 0.8)'; ctx.fillRect(1150, pwY, 40, 30); }

              game.score += 1;
              if (game.gameFrame % 10 === 0) setScore(game.score);

              gameLoop.current = requestAnimationFrame(animate);
            };

            animate();
            return () => { if (gameLoop.current) cancelAnimationFrame(gameLoop.current); };
          }, [gameState, isPaused, difficulty, highScore]);

          return (
            <div className="flex flex-col items-center justify-center min-h-screen bg-gradient-to-b from-indigo-950 via-purple-950 to-black p-4">
              <div className="text-center mb-4">
                <h1 className="text-6xl font-bold mb-2 text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-purple-500 to-pink-500 drop-shadow-lg animate-pulse">
                  NEON RUNNER
                </h1>
                <p className="text-cyan-300 text-lg font-semibold">Ultimate Edition</p>
              </div>

              <div className="relative mb-4">
                <canvas ref={canvasRef} className="border-4 border-cyan-500 rounded-xl shadow-2xl shadow-cyan-500/50" style={{ maxWidth: '100%', height: 'auto' }} />
                
                {gameState === 'menu' && (
                  <div className="absolute inset-0 flex items-center justify-center bg-black/90 rounded-xl backdrop-blur-sm">
                    <div className="text-center p-8 max-w-2xl">
                      <h2 className="text-5xl font-bold mb-6 text-cyan-400 animate-pulse">PR√äT ?</h2>
                      <div className="mb-8 space-y-2 bg-black/50 p-6 rounded-xl">
                        <p className="text-white text-lg">üíª PC: ESPACE = Sauter | ‚Üì = Se baisser | P = Pause</p>
                        <p className="text-white text-lg">üì± Mobile: Haut = Sauter | Bas = Se baisser</p>
                      </div>
                      <p className="text-yellow-300 text-xl font-bold mb-4">‚ö° CHOISIS LA DIFFICULT√â ‚ö°</p>
                      <div className="flex gap-4 justify-center mb-6">
                        <button onClick={() => startGame('easy')} className="bg-gradient-to-br from-green-500 to-green-700 text-white px-8 py-4 rounded-xl font-bold text-lg hover:scale-110 transition-all shadow-lg">üòä FACILE</button>
                        <button onClick={() => startGame('normal')} className="bg-gradient-to-br from-blue-500 to-purple-600 text-white px-8 py-4 rounded-xl font-bold text-lg hover:scale-110 transition-all shadow-lg">üéØ NORMAL</button>
                        <button onClick={() => startGame('hard')} className="bg-gradient-to-br from-red-500 to-red-700 text-white px-8 py-4 rounded-xl font-bold text-lg hover:scale-110 transition-all shadow-lg">üî• DIFFICILE</button>
                      </div>
                      <div className="bg-purple-900/50 p-6 rounded-xl space-y-2 text-sm">
                        <p className="text-cyan-300">üíé Cristaux = +50 pts (combo multiplier!)</p>
                        <p className="text-blue-300">üõ°Ô∏è Bouclier ‚Ä¢ ‚è∞ Ralentissement ‚Ä¢ üß≤ Aimant ‚Ä¢ ‚ù§Ô∏è Vie</p>
                        <p className="text-purple-300">üëæ Drones ‚Ä¢ Robots ‚Ä¢ Barri√®res ‚Ä¢ Lasers</p>
                      </div>
                    </div>
                  </div>
                )}

                {isPaused && gameState === 'playing' && (
                  <div className="absolute inset-0 flex items-center justify-center bg-black/80 rounded-xl">
                    <div className="text-center">
                      <Pause size={64} className="text-cyan-400 mx-auto mb-4" />
                      <h2 className="text-5xl font-bold text-cyan-400 mb-4">PAUSE</h2>
                      <p className="text-white text-xl">Appuie sur P pour continuer</p>
                    </div>
                  </div>
                )}

                {gameState === 'gameover' && (
                  <div className="absolute inset-0 flex items-center justify-center bg-black/90 rounded-xl backdrop-blur-sm">
                    <div className="text-center p-8">
                      <h2 className="text-5xl font-bold mb-4 text-red-400 animate-pulse">GAME OVER</h2>
                      <p className="text-white text-3xl mb-2">Score Final: <span className="text-cyan-400 font-bold">{score}</span></p>
                      <p className="text-purple-400 text-2xl mb-8">üèÜ Record: <span className="font-bold text-yellow-300">{highScore}</span></p>
                      <button onClick={() => startGame(difficulty)} className="bg-gradient-to-r from-purple-600 to-pink-600 text-white px-12 py-5 rounded-xl font-bold text-2xl hover:scale-110 transition-all duration-300 flex items-center gap-3 mx-auto shadow-2xl">
                        <RotateCcw size={32} /> REJOUER
                      </button>
                      <button onClick={() => setGameState('menu')} className="mt-4 bg-gradient-to-r from-cyan-600 to-blue-600 text-white px-10 py-3 rounded-xl font-bold text-lg hover:scale-105 transition-all">MENU PRINCIPAL</button>
                    </div>
                  </div>
                )}
              </div>

              <div className="flex gap-6 mb-4">
                <div className="bg-gradient-to-br from-cyan-900/70 to-blue-900/70 px-10 py-5 rounded-xl border-2 border-cyan-500/50 backdrop-blur-sm shadow-xl">
                  <p className="text-cyan-300 text-sm font-semibold mb-2">üí∞ SCORE</p>
                  <p className="text-white text-4xl font-bold">{score}</p>
                </div>
                <div className="bg-gradient-to-br from-purple-900/70 to-pink-900/70 px-10 py-5 rounded-xl border-2 border-purple-500/50 backdrop-blur-sm shadow-xl">
                  <p className="text-purple-300 text-sm font-semibold mb-2">üèÜ RECORD</p>
                  <p className="text-white text-4xl font-bold">{highScore}</p>
                </div>
              </div>

              <div className="text-center space-y-2 max-w-3xl">
                <p className="text-cyan-300 text-sm">‚ö° Collecte, √©vite, survie - Plus tu vas loin, plus c'est intense !</p>
                <p className="text-gray-400 text-xs mt-4">Cr√©√© avec Claude AI by Anthropic</p>
              </div>
            </div>
          );
        };

        ReactDOM.render(<NeonRunner />, document.getElementById('root'));
    </script>
</body>
</html>